# Chap1 操作系统引论

## 1.1、OS的目标和作用

### （1）操作系统定义：

OS是直接控制和管理计算机硬件、软件资源，合理地对各类作业进行调度，以方便用户使用的程序集合

### （2）操作系统的地位：

紧贴系统硬件之上，所有其他软件之下（是其他软件的共同环境）

### （3）操作系统的目标

方便性、有效性、可扩充性、开放性

### （4）操作系统的作用

作为用户和计算机间的接口，作为计算机系统的资源的管理者，作为扩充机器

## 1.2、OS的发展过程

### （1）OS发展过程

- 无OS
  - 人工操作方式：用户计算机专业人员；编程语言：机器语言；输入输出：纸袋或卡片
  - 脱机I/O方式
- OS分类

  - ***批处理系统***

    - 单道
    - 多道

  - ***分时系统***

    - **主要动力**：用户的需求
    - **目标**：对用户的请求及时响应；尽量提高系统资源的利用率
    - **原理**：一台计算机连接多个终端，计算机能***分时轮流***的为各个终端用户服务，并能及时地对用户服务请求予以响应
    - **基本特征**：多路性；独立性；及时性；交互性；

  - ***实时系统***

    - **目标**：提高系统的响应时间，对随机发生的外部事件作出及时响应并对其进行处理.

    - **分类**：

      - 实时控制系统：要求计算机能尽快处理测量系统测得的数据，以尽快实施响应控制。例如：工业控制；导弹发射；飞机飞行
      - 实时信息系统：要求计算机能对终端设备发来的服务请求及时予以正确的回答。例如：订票系统；情报检索系统。

    - **基本特征**：快速的响应时间；有限的交互能力；高可靠性

### （2）三种基本操作系统的比较

|            | 多路性             | 独立性 | 及时性        | 交互性 |  可靠性  |
| ---------- | ------------------ | ------ | ------------- | ------ | :------: |
| 批处理系统 | 无                 | 无     | 差（天，时）  | 差     |   一般   |
| 分时系统   | 多终端服务         | 有     | 好（分，秒）  | 好     |   可靠   |
| 实时系统   | 多路采集、多路控制 | 有     | 最好（ms,μs） | 一般   | 高度可靠 |



### （3）OS课程所占角度

- 多任务；单CPU；CPU具有与外设并行操作的能力
- 特别指出：
  - 程序均由CPU执行

  - CPU只能执行机器语言程序

  - CPU执行的程序均在内存中

    

## 1.3、操作系统的基本特性：

- ***并发性***:
  - **并发**：指两个或多个事件在**同一时间间隔**内发生
  - **并行**：指两个或多个事件在**同一时刻**发生。
- ***共享***：指系统中的资源供内存中的多道程序所共同使用。
  - 互斥共享方式：打印机
  - 同时访问方式：磁盘
- ***虚拟：***指通过某种技术把一个物理实体变成若干个逻辑上的对应物。
- ***异步性***：系统中并发执行的多道程序“走走停停”，以不可预知的速度向前推进。

## 1.4、操作系统的主要功能

### （1）、五大功能：

- 处理机管理功能

- 存储器管理功能

- 设备管理功能

- 文件管理功能

- 用户接口

### （2）、OS的主要任务

为多道程序的运行提供良好的运行环境，以保证多道程序能有条不紊。高效的运行，并能最大程度地提高系统中各种资源的利用率和方便用户的使用。

# 1.5、OS结构设计

- 传统的操作系统结构
  - 无结构操作系统
  - 模块化OS结构
  - 分层式OS结构
- 现代操作系统结构
  - 微内核的OS结构

# Chap2、进程的描述与控制

# 2.1、前趋图和程序执行

2.1.1、前趋图                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          

​	前趋图：一个有向无循环图，用于描述进程之间的前后关系。（前驱关系不存在循环）

结点：描述一个程序段或进程，或一条语句

有向边：结点之间的偏序或前序关系

2.1.2、程序的顺序执行（单道程序）

​	一个程序由若干个程序段组成，程序段的执行必须是顺序的。

特征：

​	顺序性：处理机的操作严格按照程序所规定的顺序执行

​	封闭性：程序一旦开始执行，其计算结果不受外界因素的影响。

​	可再现性：程序执行的结果与它的执行速度无关（与时间无关），而只与初始条件有关。（执行时的环境和初始条件相同，结果相同）

2.1.3、程序的并发执行（多道程序）

​	只有不存在前驱关系的程序之间才有可能并发执行，否则无法并发执行。

特征：

​	间断性：程序的并发执行，为完成一项任务而相互合作，程序之间共享资源，相互制约。

​	失去封闭性：程序的运行受到其他程序的影响

​	不可再现性：程序在并发执行时，多次运行初始条件相同的同一程序会得到不同的运行结果。

## 2.2、进程的描述

### 2.2.1、进程的定义和特征                                             

​	进程的定义和特征：在多道程序设计的环境下，为了描述程序在计算机系统内的执行情况，必须引入新的概念

​	进程：程序关于某个数据集合的一次执行过程。（进程是执行中的程序）

​	**进程三要素（进程实体） = PCB（进程控制块） + 程序 + 数据**

**进程的特征**：（进程和程序之间的差别）

​	结构特征：PCB（进程控制块） + 程序 + 数据 = 进程实体

​	动态性（最基本特征）：进程--进程实体的一次执行过程，有生命周期

​						   程序--程序是一组有序指令的集合，是静态的概念

​	并发性，独立性，异步性（进程按各自独立的、不可预知的速度向前推进）                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          

### 2.2.2、进程的基本状态和转换 

就绪状态：进程已获得除CPU之外的所有必须的资源，一旦得到CPU控制权，立即可以执行。（万事俱备，只欠CPU）

运行状态：进程已获得运行所需要的资源，它的程序正在处理机上执行

阻塞状态：正在执行的进程由于发生某事件而暂时无法执行时，便抛弃处理机而处于暂停状态，称该进程处于阻塞状态或等待状态。

转换：就绪 ------------>执行 ---------->就绪   ;执行----------> 阻塞 ----------->就绪

​                  进程调度               时间片完                I/O请求             I/O完成

### 2.2.3、挂起状态

​	当该操作作用于某个进程时，该进程将被挂起，意味着此时该进程处于静止状态。如果进程正在执行，它将暂停操作。若原本处于就绪状态，则该进程此时暂不接受调度。

​	引起挂起状态的原因：

终端用户的需求；父进程请求；负荷调节的需要；操作系统的需要

​	进程状态转换：

挂起状态（静止状态）到非挂起状态（活动状态）的相互转换

### 2.2.4、进程控制块

​	**PCB存放进程管理和控制信息的数据结构**

​	**进程控制块的作用**：

作为独立运行的基本单位的标志，**PCB已成为进程存在的唯一标志**。能实现间断性运行方式。提供进程管理所需的信息。提供进程调度所需的信息。实现与其他进程的同步与通信。

​	进程控制块中的信息

进程标识符（每个进程必须有一个唯一的标识符），处理机状态，进程调度信息，进程控制信息

​	进程控制块的组织形式

线性方式，链接方式（就绪队列，阻塞队列），索引方式

## 2.3、进程控制

### 2.3.1、进程的创建

​	1.进程图：描述进程的家族关系分的有向树

​	2.引起创建进程的事件

用户登入；作业调度；提供服务；应用请求

​	3.进程的创建过程

调用create创建原语

**申请空白PCB----->为新进程分配资源----->初始化进程控制块------>将新进程插入就绪队列**

### 2.3.2、进程的终止

​	1.引起进程终止的事件

正常结束；异常结束；外界干预

 	2.进程终止的过程

找出被终止进程的PCB---->若进程状态为运行，置CPU调度标志为真---->若其有子孙进程，终止其子孙进程并回收其资源----->回收终止进程的资源----->回收终止进程的PCB

### 2.3.3、进程的阻塞与唤醒

​	1.引起进程阻塞和唤醒的事件

请求系统服务；启动某种操作；新数据尚未到达；无新工作可做

​	2.进程阻塞过程（自己阻塞自己）

用block（阻塞原语）阻塞自己----->将PCB中的状态改为阻塞，并加入阻塞队列----->转进程调度

​	3.进程唤醒过程（唤醒原语由别的进程唤醒）

把阻塞进程从等待该事件的阻塞队列移出----->置进程状态为就绪状态，将PCB插入到就绪队列中

### 2.3.4、进程的挂起与激活

​	1.进程挂起过程

 检查被挂起进程的状态： 若处于活动就绪，则改为静止就绪；若处于活动阻塞，则改为静止阻塞；若挂起的进程正在执行，则重新进行进程调度

​	2.进程的激活过程

激活原语先将进程从外存调入内存； 检查该进程的状态：若为静止就绪，则改为活动就绪； 若处于静止阻塞，则改为活动阻塞。

## 2.4、进程同步

### 2.4.1、进程同步概念

​	进程同步的主要任务：是对多个相关进程在执行次序上进行协调，使并发执行的诸进程之间能按照一定的规则共享系统资源，并能很好的相互合作，从而使程序的执行具有可再现性。

​	**临界资源：一次仅允许一个进程访问的资源**

​	**进程互斥：俩进程不能同时访问同一临界资源**

​	**进程同步：某进程未获得合作进程发来的消息之前该进程等待，消息到来之后方可继续执行的合作关系。**

## 2.4.2、信号量机制

1.整形信号量

​	定义为一个表示资源数目的整型量。除初始化外仅能通过两个原子操作。

必须配合有P、V操作

2.记录型信号量

​	**引入整型信号量代表资源数目value。**

​	**value大于0表示可用资源数目**

​	**value小于0表示申请信号量数目。**

​	**value=1表示是互斥信号量**

3.AND型信号量

​	将进程在整个运行过程中所需要的所有资源，一次性全部分配给进程，待进程使用完后再一起释放。

### 2.4.3、信号量的应用

![1558252605828](E:\大二下\base_nodes\信号量互斥.png)

**1.利用信号量实现进程互斥模式**

![1558252685222](E:\大二下\base_nodes\打印机互斥.png)

**2.利用信号量实现前驱关系**

![1558252858360](E:\大二下\base_nodes\前驱关系.png)

**3.利用记录型信号量实现同步**

![1558253143938](E:\大二下\base_nodes\进程同步.png)

## 2.3、经典进程的同步问题

### 2.3.1、生产者-消费者问题



## 2.4、进程通信

1.进程通信的类型

共享存储器系统

​	基于共享数据结构的通信方式

​	基于共享存储区的通信方式

消息传递系统

管道通信

## 2.5、线程

​	线程是属于进程的，线程运行在进程空间内，同一进程所产生的线程共享同一物理内存空间，当进程退出时该进程的产生的线程都会被强制退出并清除。

​	在多线程OS中，通常一个进程包括多个线程，每个线程是利用CPU的基本单位，是花费最小开销的实体。

​	引入线程的目的：减少程序在并发执行时所付出的时空开销，使OS具有更好的并发性。

# 3、处理机调度与死锁

## 3.1、处理机调度层次和调度算法

1.高级调度(作业调度或长程调度、接纳调度)

​	决定将外存**哪几个作业**调入内存。主要用于多道批处理系统。分时，实时系统中没有。

​	做出的两个决定：**接纳多少作业，接纳哪些作业**。

2.低级调度(进程调度或短程调度)

​	决定就绪队列的**哪个进程应获得处理机。**多道批处理系统，分时，实时系统中都有。

3.中级调度

​	由中级调度来**决定把外存上的哪些又具备运行条件的就绪进程，重新调入内存**，并修改其状态为就绪状态，挂在就绪队列上等待进程调度。

## 3.2、作业与作业调度

1.先来先服务(FCFS)

​	周转时间=完成时间-到达时间

​	带权周转时间=周转时间/服务时间                                                                                                                                                                                                                      

2.短作业优先调度算法（SJF）

​	需要服务时间最短的先执行

3.高优先权调度算法(HPF)

4.高响应比优先调度算法(HRRN)

​	优先权=(等待时间+要求服务时长)/要求服务时间

## 3.3、进程调度

1.进程调度两种方式：

​	抢占式和非抢占式

​	抢占原则：优先权原则、短作业原则、时间片原则

## 3.4、实时调度

最早截止时间优先EDF

​	根据任务的截止时间来确定任务的优先级。截止时间越早，优先级越高

最低松弛度优先LLF

​	根据任务紧急的程度，来确定任务的优先级，紧急程度越高，为之赋予的优先级就越高。 

## 3.5、死锁的概述

  	死锁：是指多个进程在运行过程中因争夺资源而造成的一种僵局，当进程处于这种状态时，若无外力作用，它们都将无法再向前推进。

1.产生死锁的原因: 竞争资源、进程间推进程序非法。

2.**产生死锁的必要条件**:互斥条件(在一段时间内资源只有一个进程占用。)，请求和保持条件(进程已经保持了至少一个资源，但又提出了一个新的资源请求，产生请求进程阻塞），不剥夺条件（一个进程已获得资源，在未使用完之前不能被剥夺，只能用完时自己释放），环路等待条件

3.处理死锁的方法:预防死锁、避免死锁、检测死锁、解除死锁

## 3.7、避免死锁

​	在死锁避免方法中，把系统的状态分为安全状态和不安全状态

1.安全状态：是指系统能按某种进程的顺序为每个进程p分配其所需要的资源，直至满足每个进 程对资源的最大需求，使每个进程都可顺利的完成。如果系统无法找到这样一个安全序列则称系统处于不安全状态。

​	并不是所有的不安全状态就是死锁，但当系统进入不安全状态后，便可能进而进入死锁状态。反之只要处于安全状态就不会死锁。

2.避免死锁的实质是：系统在进行资源分配时，设法使系统不进入不安全状态。

### 3.7.2、银行家算法

​	p纸张

![1558232637178](E:\大二下\base_nodes\银行家算法1.png)

![1558232682818](E:\大二下\base_nodes\银行家算法2.png)

![1558232714415](E:\大二下\base_nodes\银行家算法3.png)

![1558232795779](E:\大二下\base_nodes\银行家算法4.png)

![1558232844156](E:\大二下\base_nodes\银行家算法5.png)

## 3.8、死锁的检测和解除

死锁定理 ：S状态的资源分配图为死锁状态的充分条件是当且仅当S状态的资源分配图是完全不可简化的。

死锁解除：剥夺资源、撤销进程 

# 4、存储器管理

## 4.1、存储器的层次结构

多级存储器结构：CPU寄存器、主存、辅存

## 4.2、程序的装入和链接

1. 程序的装入

   源代码---(编译)--->目标模块 ----(链接)----->装入模块(可执行程序)-----装入---

2. 装入方式

   1. 绝对装入方式：直接装入物理地址，适用于单任务
   2. 可重定位装入方式：装入模块装入内存后，会使装入模块中的所有逻辑地址与实际装入内存的物理地址不同。
   3. 动态运行时装入方式：允许程序运行时在内存中移动位置。装入内存后不立即把装入模块中的相对地址转换为绝对地址，而是推迟到程序真正执行时。

3. 程序的链接

   1. 静态链接：程序运行前
   2. 装入时动态链接：边装入边连接
   3. 运行时动态链接：程序执行时

## 4.3、连续分配存储器管理方式

1. **单一连续分配**

   用于单用户、单任务

2. **固定分区分配**

   将内存空间分为若干个固定大小的区域。每个区域只装入一道作业。

   分为分区大小相等、分区大小不等

3. **动态分区分配**

   原理：根据进程的实际需要，动态的分配内存。

   空闲分区表：分区序号、分区始址、分区大小

   已占分区表：作业号、起始地址、大小

   **分区分配算法：**

   1. 首次适应算法FF

      以**地址递增**的次序排列，从**表首**始查找，只查找一次。

   2. 循环首次适应算法

      从***上次找到空闲分区的下一个空闲分区***开始查找，直到找到满足要求的空闲分区。

   3. 最佳适应算法

      将所有的空闲分区***按其容量以小到大***的顺序形成空闲分区链表

4. **可重定位分区分配**

   1. 动态重定位：
      1. 地址变换过程在程序执行过程期间，随着每条指令的访问自动进行。
      2. 西横须执行时访问的内存地址是相对地址与从定位寄存器的地址相加而成的。

## 4.4、对换

对换：把内存中暂时不运行的进程或暂时不用的程序和数据调到外存，以便腾出内存空间，再把已具备运行条件的进程和进程所需要的数据和程序调入内存。

对换分类：

​	整体对换：以整个进程为单位

​	页面兑换或分段对换：以页或段为单位

进程换入：处于阻塞队列且优先级最低

进程换出：处于就绪状态且已换出的进程，换出最久的进程。

## 4.5、分页存储管理方式

​	离散分配方式。**要求把每个作业全部装入内存后方能运行。**

### 4.5.1、页面与页表

1. 分页式存储管理

   1. 将进程的逻辑地址空间分为若干个大小相等的页，并编号，从0开始。同时将内存空间分为与页面相同大小的若干个存储块，成为块，再为进程分配内存时，以块为单位将进程的若干个页分别装入到多个可以不相邻的物理块中。

2. 基本分页式存储管理

   系统若能满足一个作业要求的全部块数，此作业才能被装入内存，否则不为他分配任何内存。

3. 请求分页式存储管理

   运行一个作业，不要求把改作业的全部程序和数据都装入内存，可以把目前执行的几页调入内存的空闲块中，其他的再外存中，需要再调用。

### 4.5.2、地址变换机构

​	p纸张

## 4.6、分段存储管理方式

​	在分段存储管理方式中，作业地址空间被划分为若干个段，每个段定义了一组逻辑信息，都有自己的名字。通常用段号代替段名，每段从0开始编址，并采用一段连续地址空间。段长由逻辑信息组的长度决定。整个作业的地址空间分成多个段，逻辑地址由段号和段内地址组成。

# 6、输入输出系统

## 6.1、I/O系统的功能、模型和接口

1. I/O系统的主要任务

   完成用户提出的I/O请求，提高I/O的速率，以及提高设备的利用率，并能为更高层的进程方便地使用这些设备提供手段。

2. I/O系统的层次结构

   用户层I/O软件、设备独立性软件、设备驱动程序、中断处理程序
## 6.2、I/O设备和设备控制器

1. I/O设备的类型

2. 设备和和控制器之间的接口

   通常设备不直接和CPU进行通信而是与设备控制器通信。

   数据信号线、控制信号线、状态信号线

   3.I/O通道

​	主要目的是为了建立独立的I/O操作去解放CPU。设置通道后，CPU只需向通道发送一条I/O指令。通道完成任务后向CPU发送中断信号。

​	**I/O通道是一种特殊的处理机：指令类型单一，只用于I/O操作；通道没有内存，它与CPU共享内存。**

​	通道类型：字节多路通道、数组选择通道、数组多路通道。

​	瓶颈问题（通道价格昂贵，数量较少），解决方法，增加设备到主机的通路而不增加通道。

## 6.4、设备驱动程序

​	设备处理程序通常又称为设备驱动程序，它是I/O系统的高层与设备控制器之间的通信程序。驱动程序与硬件密切相关，通常应为每一类设备配置一种驱动程序。

​	对I/O设备控制方式:

​	1.使用轮询的可编程I/O方式

